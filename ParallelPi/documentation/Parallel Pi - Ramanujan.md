---
author:
- Янислав Василев
date: Юни 2019
title: 'Пресмятане на Pi -- Ramanujan'
---

![image](..\assets\su.jpg)

Увод в проекта
==============

Проектът реализира паралелен алгоритъм за намирането на $\frac{1}{\pi}$
по формулата на Ramanujan:
$$\frac{2\sqrt{2}}{9801}\sum_{k=0}^{\infty} \frac{(4k!)(1103 + 26390k)}{k!^4 396^(4k)}$$

Ако разгледаме формулата внимателно забялзваме, че всеки един наш член
на редицата, се нуждае от пресмятането на $k!$ и $4k!$, това означава,
че ние може да преизползваме вече пресметнатите от предходни калкулации
факториели с цел да олекотим работата на алгоритъма това е също така в
основата на кеширането на нашият алгоритъм.

Програмата удволетворява следните функционални изисквания:

-   Команден параметър задаващ точността на пресмятанията

    *`--`i=23572 или `--`iterations=23572*

    това, ще зададе на програмата да пресметне 23572 члена от сумата на
    Ramanujan, също така прецизността на решението автоматично ще бъде
    настроена на $23572 * 8$ тъй, като всеки един член на сумата добавя
    8 нови знака към $\frac{1}{\pi}$. Този параметър е задължителен.

-   Команден параметър, който задава максималния брой нишки (задачи) на
    които разделяме работата по пресмятането на $\frac{1}{\pi}$

    *`--`t=1 или `–-`threads=1*

    това, ще зададе на програмата възможност да работи с една нишка. За
    максимален ефект се препоръчва броят на логическите ядра на
    процесорът, на които програмата ще се изпълнява. В случай, че този
    параметър липсва, програмата ще се изпълни серийно (т.е с една
    нишка). Този параметър не е задължителен.

-   Команден параметър, чрез който програмата извежда подходящи
    съобщения на различните етапи от работата си, както и времето
    отделено за изчисление и резултата от изчислението

    *`--`verbosity=quiet или `--`verbosity=verbose*

    В първият случай програмата ще регистрира само минималният покриващ
    изискванията набор от съобщения (с какви аргументи е стартирана
    програмата, колко време е отнело пресмятането и резултата), а във
    вторият случай има по-подробна информация като това колко време е
    отнело на една нишка да приключи своята работа и д.р. В случай, че
    този параметър липсва програмата ще назначи служебно такъв. Този
    параметър не е задължителен.

-   Команден параметър, чрез който се указва в кой изходен файл да бъде
    изписан разултата и контролните съобщения.

    *`--`o=result.txt или `--`output =result.txt*

    В случай, че този параметър липсва програмата ще назначи автоматично
    служебно име за файла. Този параметър не е задължителен.

-   Команден параметър, чрез който се избира оптимизирана (не наивна)
    стратегия по разпределяне на работата по нишките.

    *`--`optimized*

    В случай, че този параметър не е посочен, програмата ще избере
    наивно разделяне на работата по работещите нишки. Подразбира се, че
    ако сме посочили този параметър и това програмата да се изпълнява
    серийно, то този параметър няма ефект.

-   Помощен команден параметър,

    *`--`h или `--`help*

    който изписва на екрана всички опции(командни параметри) на
    програмата, техните свойства, стойности по подразбиране и функции.

Проектиране и реализация
========================

Алгоритъмът е реализиран на C++11 на платформа Windows с Microsoft
Visual C++ компилатор, като е изпозван модела за паралелизъм по данни
или Single Program-Multiple Data(SPMD) като нишките работят асинхронно
една от друга. Архитектурата на програмата е по модела Master-Slave,
тоест имаме една основна нишка (наречена още main) чакаща всички
останали да свършат своята работа. Един начин да се стартира програмата
след като тя е компилиране е например:

*main.exe `--`iterations=100 `--`threads=8*

ще стартира програмата с осем нишки за пресмятането на сто члена от
формулата. Още при пускането на програмата всички командни параметри се
запазват в обект от тип `ProgramOptions`, който след това се ползва да
настройването на `Logger::options`, прецизността на типа, който ползва
програмата за пресмятане на $\frac{1}{\pi}$
(`boost::multiprecision::mpfr_float`) и за разпределянето на работата по
нишките, чийто задача има `SeparationStrategy` обектът. Програмата има
два вида стратегии на разпределяне на работа.

-   Наивен

    Този вид разпределение е най-базовото и с нарастване на броят
    итерации поискани от потребителя започва да създава проблеми. Това,
    което прави е например ако имаме да решим 1000 итерации с 5 нишки,
    той разделя работата по равно на всяка нишка. Така работата ще за
    всяка една от тях ще изглежда така

    *1 : \[0, 250\], 2: \[251, 500\], 3: \[501, 750\], 4: \[751,
    1000\],*

    където 1-5 са идентификатори на нишките а \[x,y\] е интервалът, в
    който нишката ще работи.

    На пръв поглед това изглежда като добро решение, но малко
    по-подробен анализ показва, че работата на нишка 4 в нашият пример е
    много по-тежка от работата на нишка 1, което води до неоптимални
    резултати.

    Алгоритъмът, който го имплементира

        simple_ranges
        NaiveSeparationStrategy::Separate(long iterations,
        short threads)
        {
            simple_ranges ranges;
            if (threads == 0)
                return ranges;

            ranges.reserve(threads);

            auto chunk = iterations / threads;
            auto remainder = iterations % threads;

            auto loopIterations = 0;
            for (auto partition = 0; 
                partition <= iterations - chunk + loopIterations; 
                partition += chunk + 1)
            {
                ranges
                .emplace_back(partition, 
                              partition + chunk > iterations ?
                              iterations : partition + chunk);
                ++loopIterations;
            }

            return ranges;
        }

-   Оптимизиран

    За разлика от наивният вид на разпределение, този няма такъв
    проблем. Ако вземем предишното ни тестово изпълнение, където с пет
    нишки трябва да пресметнем хиляда члена от сумата, този път нашето
    разпределени ще изглежда по този начин

    *1:\[0,100\]$\cup$\[900,1000\], 2:\[101,200\]$\cup$\[800,899\],
    3:\[201,300\]$\cup$\[700,799\], 4:\[301,400\]$\cup$\[600,699\],
    5:\[401,500\]$\cup$\[500,599\]*

    Вижда се, че сега работата наистина е не само по разпределена по
    равно, но и по сложност.

    Алгоритъмът, реализиращ това разпределение

        advanced_ranges
        OptimizedSeparationStrategy::Separate(long iterations, 
        short threads)
        {
            advanced_ranges ranges;
            if (threads == 0)
                return ranges;

            ranges.reserve(threads);

            auto leftChunk = 0, rightChunk = 0;
            
            if ((iterations / threads) % 2 != 0)
            {
                leftChunk = (iterations / threads) / 2;
                rightChunk = (iterations / threads) / 2 + 1;
            }
            else
            {
                leftChunk = rightChunk
                          = (iterations / threads) / 2;
            }

            long l = 0, 
                 r = iterations, 
                 previous_l = l, previous_r = r;

            while (l < r)
            {
                ranges
                .emplace_back(
                   std::make_pair(previous_l, l + leftChunk),
                   std::make_pair(r - rightChunk, previous_r)
                );

                previous_l = l + leftChunk + 1;
                previous_r = r - rightChunk - 1;

                l += leftChunk;
                r -= rightChunk;
            }

            // make last range excluding last number
            // as it will be calculated from the 
            // second last range.
            ranges.back().first.second--;

            return ranges;
        }

След избирането на стратегия същинската работа започва. Основната нишка
(main \<-\> master) има за цел да изчака всички работещи (workers \<-\>
slaves) и след това да запише резултата.

Тестване
========

Програмата е тествана на тестовият сървър rmi.yacht.net.

Следната таблица е построена от резултатите при пресмятане на 10 000
члена от сумата при следните опции

*`--`iterations=10000 `--`threads=X (`--`optimized)*

програмата е компилирана с компилатор g++ с опция -О3 за максимално
бързодействие.

Ускорението, което се получава от предишната таблица.

![image](..\assets\Sp.JPG)

Ефикасността, която се получава.

![image](..\assets\Ep.JPG)

**T1** -- времето за изпълнение на серийната програма (използваща една
нишка). **Tp** -- времето за изпълнение на паралелната програма,
използваща p нишки. **Sp = T1/Tp** -- ускорението, което програмата има
при използването на p нишки. **Ep = Sp/p** -- ефективността
(ефикасността) на програмата при използването на p нишки.
